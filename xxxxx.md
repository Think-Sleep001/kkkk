# TCP三次握手

## 1 TCP的三次握手发生在哪个层？

首先我们要明白TCP/IP的协议族各层：应用层，传输层，网络层，数据链路层。而TCP的三次握手就发生在传输层，其目的就是在两台设备进行数据传输前检测其两台设备之间的连接情况。以确保彼此之间可以正常通信，协商连接参数


## 2TCP运输连接的三个过程

·建立TCP连接，也就是通过三次报文握手来建立TCP连接。
·数据传送，在通过三次握手建立起稳定的数据传送连接后开始进行数据传送
`释放连接，也就是在数据传输完成后，还要通过四次挥手来释放tcp连接。![](D:\liulanqixaizai\免费在线消除笔—一键去杂物,让您轻松摆脱logo、文字、标志、污渍等瑕疵\DM_20231022204044_001.jpg)

## 3TCP的首部格式（选择性理解）![](D:\liulanqixaizai\免费在线消除笔—一键去杂物,让您轻松摆脱logo、文字、标志、污渍等瑕疵\DM_20231022203855_001.jpg)

**源端口:** 占16比特，写入源端口号，用来 **标识发送该TCP报文段的应用进程。** **目的端口：** 占16比特，写入目的端口号，用来**标识接收该TCP报文段的应用进程。**

**序号:** 占32比特，取值范围[0,2^32-1]，序号增加到最后一个后，下一个序号就又回到0。**指出本TCP报文段数据载荷的第一个字节的序号。**

**确认号：** 占32比特，取值范围[0,2^32-1]，确认号增加到最后一个后，下一个确认号就又回到0。指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。若确认号=n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。

***确认标志位ACK*：** 取值为1时确认号字段才有效；取值为0时确认号字段无效。**TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。**

**数据偏移:** 占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上是指出了TCP报文段的首部长度。

**窗口：** 占16比特，以字节为单位。**指出发送本报文段的一方的接收窗。**

**同步标志位SYN：** 在TCP连接建立时用来同步序号。**终止标志位FIN：** 用来释放TCP连接。**复位标志位RST：** 用来复位TCP连接。

**推送标志位PSH：** 接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。

**校验和：** 占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。

**紧急指针：** 占16比特，以字节为单位，用来指明紧急数据的长度。

**填充：** 由于选项的长度可变，因此使用填充来 **确保报文段首部能被4整除**，(因为数据偏移字段，也就是首部长度字段，是以4字节为单位的)。

## 4TCP连接的建立（三次握手）

人们通常把TCP建立连接的过程叫做握手，握手需要在客户机和服务器之间交换三个TCP报文段，被称之为三报文握手，至于为什么要进行三次握手呢？主要是为了进行一系列情况的确认，确保稍后数据传输的可靠性，一致性，完整性。
在此我将用图片来详细解释TCP的三次握手

### 第一次握手

![](D:\liulanqixaizai\免费在线消除笔—一键去杂物,让您轻松摆脱logo、文字、标志、污渍等瑕疵\DM_20231022204015_001.jpg)
首先客户端发起TCP连接建立申请（这叫做主动打开连接，但是服务器端是因为接收到客户端的申请而打开连接的，所以客户端是被动打开)。在此客户端会向服务器端发送请求数据包，数据包里包含报文段SYN=1 seq=x。

什么是SYN=1?seq=x呢？我相信很多刚开始学到小伙伴都会有这样的疑问，但是大多数文章很少给出具体的解释，下面我给大家详细介绍一下

**SYN=1**：当要建立TCP连接时，通信的一方会发送一个SYN=1的数据报这个表示连接请求。即如果你在一个通讯设备向另一个通讯设备发送的报文包里有SYN=1就代表这一方要向另一方请求建立TCP连接

**seq=x**：其实这里的x并不指字母x，这里的x是表示第一次握手所发送的数据包的32位数字的序列号。**但是请务必要记住这个x是TCP客户进程所选择的初始序号**，到下面还会有TCP服务器进程所选择的初始序列号，这两个可是不一样的！（序列号在TCP通讯中用于识别数据包在传输中的**顺序**和唯一性。提到顺序你可以往后看一看后续报文段的序号就会变成x+)

注意TCP规定SYN被设置为1的报文段不能携带数据但要消耗掉一个序号

再澄清一个概念，TCP连接请求报文是用于请求建立连接的数据包，并不包含实际应用数据

### 第二次握手

![](D:\liulanqixaizai\免费在线消除笔—一键去杂物,让您轻松摆脱logo、文字、标志、污渍等瑕疵\DM_20231022203930_001.jpg)

TCP服务器进程收到TCP连接请求报文后，如果同意建立连接，则向TCP客户端发送TCP连接请求确认报文段，并进入同步已接收状态。

·同步位SYN=1这个不用多说，只要碰见SYN=1的情况都是一方向另一方发送连接请求

ACK=1代表已经确认收到第一次握手中客户端的请求。在此我说明一点，只要是确认收到了对方的来信，要给对方回信的时候都要回复ACK=1

·seq=y。序号字段seq被设置一个初始值y（y位一个32位数字）这代表TCP服务器进程所选择的初始序号

·ack=x+1。**小写的ack表示确认号**。即接收到的上一次客户端传来的seq然后+1，再发送给客户端。提示客户端已经成功接收上一次所有数据。

请注意第二次握手的报文段也不能携带数据，因为它是SYN=1的报文段，但是同样要消耗一个序号。

#### 为什么SYN=1的报文段不能携带数据？

因为SYN=1的报文段仅适用于建立连接，以确保连接的可靠性和协商连接参数。一旦三次握手完成，连接建立，应用层数据将在后续TCP数据包中传输，这些数据包中将不会再带有SYN标志位

### 第三次握手

![](D:\liulanqixaizai\免费在线消除笔—一键去杂物,让您轻松摆脱logo、文字、标志、污渍等瑕疵\DM_20231022203954_001.jpg)

**TCP客户进程收到服务端的TCP连接*请求确认报文段*后，还要向TCP服务进程发送一个普通的TCP确认报文段并进入连接已建立状态**

·ACK=1.表示这是一个普通的TCP确认报文段

·序号为seq=x+1.**表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；**

·ack=y+1.表示确认收到服务器序号seq，并将其值加1作为自己确认号ack的值

请注意TCP规定，普通的TCP确认报文段可以携带数据，如果携带数据了就会消耗序列号。反之，如果不携带数据则不会消耗序列号，

#### 为什么用三次握手而不用两次握手？

请注意，由于我们改为两报文握手，因此TCP服务器进程发送完TCP连接请求确认报文段后，进入的是连接已建立状态，而不像三报文握手那样进入同步已接收状态，TCP服务器进程并等待TCP客户进程发来针对TCP连接请求确认报文段的普通确认报文段。TCP客户进程收到TCP连接请求确认报文段后进入TCP连接已建立状态，但不会给TCP服务器进程发送针对该报文段的普通确认报文段。

现在，TCP双方都处于连接已建立状态，他们可以相互传输数据，之后可以通过四报文挥手来释放连接，TCP双方都进入了关闭状态。
一段时间后，之前滞留在网络中的那个失效的TCP连接请求报文段到达了TCP服务器进程，TCP 服务器进程会误认为这是TCP客户进程又发起了一个新的TCP连接请求，于是给TCP客户进程发送TCP连接请求确认报文段并进入连接已建立状态。

该报文段到达TCP客户进程，由于TCP客户进程并没有发起新的TCP连接请求，并且处于关闭状态，因此不会理会该报文段。

但TCP服务器进程已进入了连接已建立状态，他认为新的TCP连接已建立好了，并一直等待TCP客户进程发来数据。这将白白浪费TCP服务器进程所在主机的很多资源。

综上所述，采用三报文握手，而不是两报文握手来建立TCP连接，是为了防止已失效的连接请求报文段突然又传送到了TCP服务器进程因而导致错误。


两次握手文字总结
三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。

我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。

## 补充知识

协议所在层
网络层：IP、ICMP、ARP、RARP、BOOTP
传输层：TCP、UDP
应用层：FTP、HTTP、DNS、TELNET、SMTP

ACK是确认值(Acknowledgement)，为1便是确认连接。
ack是确认编号(Acknowledgement Number)，即接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。

综上所述ack就是表示接受到了对方的序列号，并且+1发过去。